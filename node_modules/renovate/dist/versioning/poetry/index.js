"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.api = exports.isValid = exports.supportedRangeStrategies = exports.supportsRanges = exports.urls = exports.displayName = exports.id = void 0;
const semver_utils_1 = require("semver-utils");
const logger_1 = require("../../logger");
const npm_1 = require("../npm");
const pep440_1 = require("../pep440");
exports.id = 'poetry';
exports.displayName = 'Poetry';
exports.urls = ['https://python-poetry.org/docs/versions/'];
exports.supportsRanges = true;
exports.supportedRangeStrategies = ['bump', 'extend', 'pin', 'replace'];
function notEmpty(s) {
    return s !== '';
}
function getVersionParts(input) {
    const versionParts = input.split('-');
    if (versionParts.length === 1) {
        return [input, ''];
    }
    return [versionParts[0], '-' + versionParts[1]];
}
function padZeroes(input) {
    if (/[~^*]/.test(input)) {
        // ignore ranges
        return input;
    }
    const [output, stability] = getVersionParts(input);
    const sections = output.split('.');
    while (sections.length < 3) {
        sections.push('0');
    }
    return sections.join('.') + stability;
}
// This function works like cargo2npm, but it doesn't
// add a '^', because poetry treats versions without operators as
// exact versions.
function poetry2npm(input) {
    return input
        .split(',')
        .map((str) => str.trim())
        .filter(notEmpty)
        .join(' ');
}
// NOTE: This function is copied from cargo versioning code.
// Poetry uses commas (like in cargo) instead of spaces (like in npm)
// for AND operation.
function npm2poetry(input) {
    // Note: this doesn't remove the ^
    const res = input
        .split(' ')
        .map((str) => str.trim())
        .filter(notEmpty);
    const operators = ['^', '~', '=', '>', '<', '<=', '>='];
    for (let i = 0; i < res.length - 1; i += 1) {
        if (operators.includes(res[i])) {
            const newValue = res[i] + ' ' + res[i + 1];
            res.splice(i, 2, newValue);
        }
    }
    return res.join(', ').replace(/\s*,?\s*\|\|\s*,?\s*/, ' || ');
}
const equals = (a, b) => {
    try {
        return npm_1.api.equals(padZeroes(a), padZeroes(b));
    }
    catch (err) /* istanbul ignore next */ {
        return pep440_1.api.equals(a, b);
    }
};
const getMajor = (version) => {
    try {
        return npm_1.api.getMajor(padZeroes(version));
    }
    catch (err) /* istanbul ignore next */ {
        return pep440_1.api.getMajor(version);
    }
};
const getMinor = (version) => {
    try {
        return npm_1.api.getMinor(padZeroes(version));
    }
    catch (err) /* istanbul ignore next */ {
        return pep440_1.api.getMinor(version);
    }
};
const getPatch = (version) => {
    try {
        return npm_1.api.getPatch(padZeroes(version));
    }
    catch (err) /* istanbul ignore next */ {
        return pep440_1.api.getPatch(version);
    }
};
const isGreaterThan = (a, b) => {
    try {
        return npm_1.api.isGreaterThan(padZeroes(a), padZeroes(b));
    }
    catch (err) /* istanbul ignore next */ {
        return pep440_1.api.isGreaterThan(a, b);
    }
};
const isLessThanRange = (version, range) => npm_1.api.isVersion(padZeroes(version)) &&
    npm_1.api.isLessThanRange(padZeroes(version), poetry2npm(range));
const isValid = (input) => npm_1.api.isValid(poetry2npm(input));
exports.isValid = isValid;
const isStable = (version) => npm_1.api.isStable(padZeroes(version));
const isVersion = (input) => npm_1.api.isVersion(padZeroes(input));
const matches = (version, range) => npm_1.api.isVersion(padZeroes(version)) &&
    npm_1.api.matches(padZeroes(version), poetry2npm(range));
const getSatisfyingVersion = (versions, range) => npm_1.api.getSatisfyingVersion(versions, poetry2npm(range));
const minSatisfyingVersion = (versions, range) => npm_1.api.minSatisfyingVersion(versions, poetry2npm(range));
const isSingleVersion = (constraint) => (constraint.trim().startsWith('=') &&
    isVersion(constraint.trim().substring(1).trim())) ||
    isVersion(constraint.trim());
function handleShort(operator, currentValue, newVersion) {
    const toVersionMajor = getMajor(newVersion);
    const toVersionMinor = getMinor(newVersion);
    const split = currentValue.split('.');
    if (split.length === 1) {
        // [^,~]4
        return `${operator}${toVersionMajor}`;
    }
    if (split.length === 2) {
        // [^,~]4.1
        return `${operator}${toVersionMajor}.${toVersionMinor}`;
    }
    return null;
}
function getNewValue({ currentValue, rangeStrategy, currentVersion, newVersion, }) {
    if (rangeStrategy === 'replace') {
        const npmCurrentValue = poetry2npm(currentValue);
        try {
            const massagedNewVersion = padZeroes(newVersion);
            if (npm_1.api.isVersion(massagedNewVersion) &&
                npm_1.api.matches(massagedNewVersion, npmCurrentValue)) {
                return currentValue;
            }
        }
        catch (err) /* istanbul ignore next */ {
            logger_1.logger.info({ err }, 'Poetry versioning: Error caught checking if newVersion satisfies currentValue');
        }
        const parsedRange = (0, semver_utils_1.parseRange)(npmCurrentValue);
        const element = parsedRange[parsedRange.length - 1];
        if (parsedRange.length === 1 && element.operator) {
            if (element.operator === '^') {
                const version = handleShort('^', npmCurrentValue, newVersion);
                if (version) {
                    return npm2poetry(version);
                }
            }
            if (element.operator === '~') {
                const version = handleShort('~', npmCurrentValue, newVersion);
                if (version) {
                    return npm2poetry(version);
                }
            }
        }
    }
    if (!npm_1.api.isVersion(newVersion)) {
        logger_1.logger.debug('Cannot massage python version to npm - returning currentValue');
        return currentValue;
    }
    try {
        const newSemver = npm_1.api.getNewValue({
            currentValue: poetry2npm(currentValue),
            rangeStrategy,
            currentVersion,
            newVersion,
        });
        const newPoetry = npm2poetry(newSemver);
        return newPoetry;
    }
    catch (err) /* istanbul ignore next */ {
        logger_1.logger.debug({ currentValue, rangeStrategy, currentVersion, newVersion, err }, 'Could not generate new value using npm.getNewValue()');
        return currentValue;
    }
}
function sortVersions(a, b) {
    return npm_1.api.sortVersions(padZeroes(a), padZeroes(b));
}
exports.api = {
    equals,
    getMajor,
    getMinor,
    getPatch,
    getNewValue,
    getSatisfyingVersion,
    isCompatible: isVersion,
    isGreaterThan,
    isLessThanRange,
    isSingleVersion,
    isStable,
    isValid: exports.isValid,
    isVersion,
    matches,
    minSatisfyingVersion,
    sortVersions,
};
exports.default = exports.api;
//# sourceMappingURL=index.js.map