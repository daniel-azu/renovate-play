"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateArtifacts = void 0;
const p_map_1 = __importDefault(require("p-map"));
const datasource_1 = require("../../../datasource");
const terraform_provider_1 = require("../../../datasource/terraform-provider");
const logger_1 = require("../../../logger");
const versioning_1 = require("../../../versioning");
const hash_1 = require("./hash");
const util_1 = require("./util");
async function updateAllLocks(locks) {
    const updates = await (0, p_map_1.default)(locks, async (lock) => {
        const updateConfig = {
            versioning: 'hashicorp',
            datasource: 'terraform-provider',
            depName: lock.lookupName,
        };
        const { releases } = await (0, datasource_1.getPkgReleases)(updateConfig);
        const versioning = (0, versioning_1.get)(updateConfig.versioning);
        const versionsList = releases.map((release) => release.version);
        const newVersion = versioning.getSatisfyingVersion(versionsList, lock.constraints);
        // if the new version is the same as the last, signal that no update is needed
        if (newVersion === lock.version) {
            return null;
        }
        const update = {
            newVersion,
            newConstraint: lock.constraints,
            newHashes: await hash_1.TerraformProviderHash.createHashes(lock.registryUrl, lock.lookupName, newVersion),
            ...lock,
        };
        return update;
    }, { concurrency: 4 } // allow to look up 4 lock in parallel
    );
    return updates.filter(Boolean);
}
async function updateArtifacts({ packageFileName, updatedDeps, config, }) {
    var _a;
    logger_1.logger.debug(`terraform.updateArtifacts(${packageFileName})`);
    const lockFilePath = (0, util_1.findLockFile)(packageFileName);
    try {
        const lockFileContent = await (0, util_1.readLockFile)(lockFilePath);
        if (!lockFileContent) {
            logger_1.logger.debug('No .terraform.lock.hcl found');
            return null;
        }
        const locks = (0, util_1.extractLocks)(lockFileContent);
        if (!locks) {
            logger_1.logger.debug('No Locks in .terraform.lock.hcl found');
            return null;
        }
        const updates = [];
        if (config.updateType === 'lockFileMaintenance') {
            // update all locks in the file during maintenance --> only update version in constraints
            const maintenanceUpdates = await updateAllLocks(locks);
            updates.push(...maintenanceUpdates);
        }
        else if (['provider', 'required_provider'].includes(updatedDeps[0].depType)) {
            // update only specific locks but with constrain updates
            const dep = updatedDeps[0];
            const lookupName = (_a = dep.lookupName) !== null && _a !== void 0 ? _a : dep.depName;
            // handle cases like `Telmate/proxmox`
            const massagedLookupName = lookupName.toLowerCase();
            const repository = massagedLookupName.includes('/')
                ? massagedLookupName
                : `hashicorp/${massagedLookupName}`;
            const registryUrl = dep.registryUrls
                ? dep.registryUrls[0]
                : terraform_provider_1.TerraformProviderDatasource.defaultRegistryUrls[0];
            const newConstraint = (0, util_1.isPinnedVersion)(config.newValue)
                ? config.newVersion
                : config.newValue;
            const updateLock = locks.find((value) => value.lookupName === repository);
            const update = {
                newVersion: config.newVersion,
                newConstraint,
                newHashes: await hash_1.TerraformProviderHash.createHashes(registryUrl, repository, config.newVersion),
                ...updateLock,
            };
            updates.push(update);
        }
        // if no updates have been found or there are failed hashes abort
        if (updates.length === 0 ||
            updates.some((value) => value.newHashes == null)) {
            return null;
        }
        const res = (0, util_1.writeLockUpdates)(updates, lockFilePath, lockFileContent);
        return res ? [res] : null;
    }
    catch (err) {
        /* istanbul ignore next */
        return [
            {
                artifactError: {
                    lockFile: lockFilePath,
                    stderr: err.message,
                },
            },
        ];
    }
}
exports.updateArtifacts = updateArtifacts;
//# sourceMappingURL=index.js.map