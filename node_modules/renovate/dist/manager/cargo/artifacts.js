"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateArtifacts = void 0;
const shlex_1 = require("shlex");
const error_messages_1 = require("../../constants/error-messages");
const logger_1 = require("../../logger");
const exec_1 = require("../../util/exec");
const fs_1 = require("../../util/fs");
async function cargoUpdate(manifestPath, packageName) {
    let cmd = `cargo update --manifest-path ${(0, shlex_1.quote)(manifestPath)}`;
    if (packageName) {
        cmd += ` --package ${(0, shlex_1.quote)(packageName)}`;
    }
    const execOptions = {
        docker: {
            image: 'rust',
        },
    };
    try {
        await (0, exec_1.exec)(cmd, execOptions);
    }
    catch (err) /* istanbul ignore next */ {
        // Two different versions of one dependency can be present in the same
        // crate, and when that happens an attempt to update it with --package ${dep}
        // key results in cargo exiting with error code `101` and an error message:
        // "error: There are multiple `${dep}` packages in your project".
        //
        // If exception `err` was caused by this, we execute `updateAll` function
        // instead of returning an error. `updateAll` function just executes
        // "cargo update --manifest-path ${localPackageFileName}" without the `--package` key.
        //
        // If exception `err` was not caused by this, we just rethrow it. It will be caught
        // by the outer try { } catch {} and processed normally.
        const msgStart = 'error: There are multiple';
        if (err.code === 101 && err.stderr.startsWith(msgStart)) {
            cmd = cmd.replace(/ --package.*/, '');
            await (0, exec_1.exec)(cmd, execOptions);
        }
        else {
            throw err; // this is caught below
        }
    }
}
async function updateArtifacts({ packageFileName, updatedDeps, newPackageFileContent, config, }) {
    var _a;
    logger_1.logger.debug(`cargo.updateArtifacts(${packageFileName})`);
    const isLockFileMaintenance = config.updateType === 'lockFileMaintenance';
    if (!isLockFileMaintenance &&
        (updatedDeps === undefined || updatedDeps.length < 1)) {
        logger_1.logger.debug('No updated cargo deps - returning null');
        return null;
    }
    // For standalone package crates, the `Cargo.lock` will be in the same
    // directory as `Cargo.toml` (ie. a sibling). For cargo workspaces, it
    // will be further up.
    const lockFileName = await (0, fs_1.findLocalSiblingOrParent)(packageFileName, 'Cargo.lock');
    const existingLockFileContent = lockFileName
        ? await (0, fs_1.readLocalFile)(lockFileName)
        : null;
    if (!existingLockFileContent) {
        logger_1.logger.debug('No Cargo.lock found');
        return null;
    }
    try {
        await (0, fs_1.writeLocalFile)(packageFileName, newPackageFileContent);
        logger_1.logger.debug('Updating ' + lockFileName);
        for (let i = 0; i < updatedDeps.length; i += 1) {
            const dep = updatedDeps[i];
            // Update dependency `${dep}` in Cargo.lock file corresponding to Cargo.toml file located
            // at ${localPackageFileName} path
            await cargoUpdate(packageFileName, (_a = dep.lookupName) !== null && _a !== void 0 ? _a : dep.depName);
        }
        if (isLockFileMaintenance) {
            await cargoUpdate(packageFileName);
        }
        logger_1.logger.debug('Returning updated Cargo.lock');
        const newCargoLockContent = await (0, fs_1.readLocalFile)(lockFileName);
        if (existingLockFileContent === newCargoLockContent) {
            logger_1.logger.debug('Cargo.lock is unchanged');
            return null;
        }
        return [
            {
                file: {
                    name: lockFileName,
                    contents: newCargoLockContent,
                },
            },
        ];
    }
    catch (err) {
        // istanbul ignore if
        if (err.message === error_messages_1.TEMPORARY_ERROR) {
            throw err;
        }
        logger_1.logger.warn({ err }, 'Failed to update Cargo lock file');
        return [
            {
                artifactError: {
                    lockFile: lockFileName,
                    stderr: err.message,
                },
            },
        ];
    }
}
exports.updateArtifacts = updateArtifacts;
//# sourceMappingURL=artifacts.js.map