"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateArtifacts = void 0;
const is_1 = __importDefault(require("@sindresorhus/is"));
const shlex_1 = require("shlex");
const upath_1 = require("upath");
const global_1 = require("../../config/global");
const error_messages_1 = require("../../constants/error-messages");
const platforms_1 = require("../../constants/platforms");
const logger_1 = require("../../logger");
const exec_1 = require("../../util/exec");
const fs_1 = require("../../util/fs");
const git_1 = require("../../util/git");
const host_rules_1 = require("../../util/host-rules");
const semver_1 = require("../../versioning/semver");
function getPreCommands() {
    const credentials = (0, host_rules_1.find)({
        hostType: platforms_1.PLATFORM_TYPE_GITHUB,
        url: 'https://api.github.com/',
    });
    let preCommands = null;
    if (credentials === null || credentials === void 0 ? void 0 : credentials.token) {
        const token = (0, shlex_1.quote)(credentials.token);
        preCommands = [
            `git config --global url.\"https://${token}@github.com/\".insteadOf \"https://github.com/\"`, // eslint-disable-line no-useless-escape
        ];
    }
    return preCommands;
}
function getUpdateImportPathCmds(updatedDeps, { constraints, newMajor }) {
    const updateImportCommands = updatedDeps
        .map((dep) => dep.depName)
        .filter((x) => !x.startsWith('gopkg.in'))
        .map((depName) => `mod upgrade --mod-name=${depName} -t=${newMajor}`);
    if (updateImportCommands.length > 0) {
        let installMarwanModArgs = 'install github.com/marwan-at-work/mod/cmd/mod@latest';
        const gomodModCompatibility = constraints === null || constraints === void 0 ? void 0 : constraints.gomodMod;
        if (gomodModCompatibility) {
            if (gomodModCompatibility.startsWith('v') &&
                (0, semver_1.isValid)(gomodModCompatibility.replace(/^v/, ''))) {
                installMarwanModArgs = installMarwanModArgs.replace(/@latest$/, `@${gomodModCompatibility}`);
            }
            else {
                logger_1.logger.debug({ gomodModCompatibility }, 'marwan-at-work/mod compatibility range is not valid - skipping');
            }
        }
        else {
            logger_1.logger.debug('No marwan-at-work/mod compatibility range found - installing marwan-at-work/mod latest');
        }
        updateImportCommands.unshift(`go ${installMarwanModArgs}`);
    }
    return updateImportCommands;
}
function useModcacherw(goVersion) {
    var _a;
    if (!is_1.default.string(goVersion)) {
        return true;
    }
    const [, majorPart, minorPart] = (_a = /(\d+)\.(\d+)/.exec(goVersion)) !== null && _a !== void 0 ? _a : [];
    const [major, minor] = [majorPart, minorPart].map((x) => parseInt(x, 10));
    return (!Number.isNaN(major) &&
        !Number.isNaN(minor) &&
        (major > 1 || (major === 1 && minor >= 14)));
}
async function updateArtifacts({ packageFileName: goModFileName, updatedDeps, newPackageFileContent: newGoModContent, config, }) {
    var _a, _b, _c, _d;
    logger_1.logger.debug(`gomod.updateArtifacts(${goModFileName})`);
    const sumFileName = goModFileName.replace(/\.mod$/, '.sum');
    const existingGoSumContent = await (0, fs_1.readLocalFile)(sumFileName);
    if (!existingGoSumContent) {
        logger_1.logger.debug('No go.sum found');
        return null;
    }
    const vendorDir = (0, upath_1.join)((0, upath_1.dirname)(goModFileName), 'vendor/');
    const vendorModulesFileName = (0, upath_1.join)(vendorDir, 'modules.txt');
    const useVendor = (await (0, fs_1.readLocalFile)(vendorModulesFileName)) !== null;
    try {
        const massagedGoMod = newGoModContent.replace(/\n(replace\s+[^\s]+\s+=>\s+\.\.\/.*)/g, '\n// renovate-replace $1');
        if (massagedGoMod !== newGoModContent) {
            logger_1.logger.debug('Removed some relative replace statements from go.mod');
        }
        await (0, fs_1.writeLocalFile)(goModFileName, massagedGoMod);
        const cmd = 'go';
        const execOptions = {
            cwdFile: goModFileName,
            extraEnv: {
                GOPATH: await (0, fs_1.ensureCacheDir)('go'),
                GOPROXY: process.env.GOPROXY,
                GOPRIVATE: process.env.GOPRIVATE,
                GONOPROXY: process.env.GONOPROXY,
                GONOSUMDB: process.env.GONOSUMDB,
                GOFLAGS: useModcacherw((_a = config.constraints) === null || _a === void 0 ? void 0 : _a.go) ? '-modcacherw' : null,
                CGO_ENABLED: (0, global_1.getGlobalConfig)().binarySource === 'docker' ? '0' : null,
            },
            docker: {
                image: 'go',
                tagConstraint: (_b = config.constraints) === null || _b === void 0 ? void 0 : _b.go,
                tagScheme: 'npm',
                preCommands: getPreCommands(),
            },
        };
        const execCommands = [];
        let args = 'get -d ./...';
        logger_1.logger.debug({ cmd, args }, 'go get command included');
        execCommands.push(`${cmd} ${args}`);
        // Update import paths on major updates above v1
        const isImportPathUpdateRequired = ((_c = config.postUpdateOptions) === null || _c === void 0 ? void 0 : _c.includes('gomodUpdateImportPaths')) &&
            config.updateType === 'major' &&
            config.newMajor > 1;
        if (isImportPathUpdateRequired) {
            const updateImportCmds = getUpdateImportPathCmds(updatedDeps, config);
            if (updateImportCmds.length > 0) {
                logger_1.logger.debug(updateImportCmds, 'update import path commands included');
                // The updates
                execCommands.push(...updateImportCmds);
            }
        }
        const isGoModTidyRequired = ((_d = config.postUpdateOptions) === null || _d === void 0 ? void 0 : _d.includes('gomodTidy')) ||
            config.updateType === 'major';
        if (isGoModTidyRequired) {
            args = 'mod tidy';
            logger_1.logger.debug({ cmd, args }, 'go mod tidy command included');
            execCommands.push(`${cmd} ${args}`);
        }
        if (useVendor) {
            args = 'mod vendor';
            logger_1.logger.debug({ cmd, args }, 'go mod vendor command included');
            execCommands.push(`${cmd} ${args}`);
            if (isGoModTidyRequired) {
                args = 'mod tidy';
                logger_1.logger.debug({ cmd, args }, 'go mod tidy command included');
                execCommands.push(`${cmd} ${args}`);
            }
        }
        // We tidy one more time as a solution for #6795
        if (isGoModTidyRequired) {
            args = 'mod tidy';
            logger_1.logger.debug({ cmd, args }, 'additional go mod tidy command included');
            execCommands.push(`${cmd} ${args}`);
        }
        await (0, exec_1.exec)(execCommands, execOptions);
        const status = await (0, git_1.getRepoStatus)();
        if (!status.modified.includes(sumFileName)) {
            return null;
        }
        logger_1.logger.debug('Returning updated go.sum');
        const res = [
            {
                file: {
                    name: sumFileName,
                    contents: await (0, fs_1.readLocalFile)(sumFileName),
                },
            },
        ];
        // Include all the .go file import changes
        if (isImportPathUpdateRequired) {
            logger_1.logger.debug('Returning updated go source files for import path changes');
            for (const f of status.modified) {
                if (f.endsWith('.go')) {
                    res.push({
                        file: {
                            name: f,
                            contents: await (0, fs_1.readLocalFile)(f),
                        },
                    });
                }
            }
        }
        if (useVendor) {
            for (const f of status.modified.concat(status.not_added)) {
                if (f.startsWith(vendorDir)) {
                    res.push({
                        file: {
                            name: f,
                            contents: await (0, fs_1.readLocalFile)(f),
                        },
                    });
                }
            }
            for (const f of status.deleted || []) {
                res.push({
                    file: {
                        name: '|delete|',
                        contents: f,
                    },
                });
            }
        }
        const finalGoModContent = (await (0, fs_1.readLocalFile)(goModFileName, 'utf8')).replace(/\/\/ renovate-replace /g, '');
        if (finalGoModContent !== newGoModContent) {
            logger_1.logger.debug('Found updated go.mod after go.sum update');
            res.push({
                file: {
                    name: goModFileName,
                    contents: finalGoModContent,
                },
            });
        }
        return res;
    }
    catch (err) {
        // istanbul ignore if
        if (err.message === error_messages_1.TEMPORARY_ERROR) {
            throw err;
        }
        logger_1.logger.debug({ err }, 'Failed to update go.sum');
        return [
            {
                artifactError: {
                    lockFile: sumFileName,
                    stderr: err.message,
                },
            },
        ];
    }
}
exports.updateArtifacts = updateArtifacts;
//# sourceMappingURL=artifacts.js.map