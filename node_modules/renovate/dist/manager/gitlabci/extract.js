"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractAllPackageFiles = exports.extractPackageFile = void 0;
const is_1 = __importDefault(require("@sindresorhus/is"));
const js_yaml_1 = require("js-yaml");
const logger_1 = require("../../logger");
const fs_1 = require("../../util/fs");
const extract_1 = require("../dockerfile/extract");
const utils_1 = require("./utils");
function skipCommentLines(lines, lineNumber) {
    let ln = lineNumber;
    const commentsRe = /^\s*#/;
    while (ln < lines.length - 1 && commentsRe.test(lines[ln])) {
        ln += 1;
    }
    return { line: lines[ln], lineNumber: ln };
}
function extractPackageFile(content) {
    const deps = [];
    try {
        const lines = content.split('\n');
        for (let lineNumber = 0; lineNumber < lines.length; lineNumber += 1) {
            const line = lines[lineNumber];
            const imageMatch = /^\s*image:\s*'?"?([^\s'"]+|)'?"?\s*$/.exec(line);
            if (imageMatch) {
                switch (imageMatch[1]) {
                    case '': {
                        const imageNameLine = skipCommentLines(lines, lineNumber + 1);
                        const imageNameMatch = /^\s*name:\s*'?"?([^\s'"]+|)'?"?\s*$/.exec(imageNameLine.line);
                        if (imageNameMatch) {
                            lineNumber = imageNameLine.lineNumber;
                            logger_1.logger.trace(`Matched image name on line ${lineNumber}`);
                            const currentFrom = imageNameMatch[1];
                            const dep = (0, extract_1.getDep)(currentFrom);
                            dep.depType = 'image-name';
                            deps.push(dep);
                        }
                        break;
                    }
                    default: {
                        logger_1.logger.trace(`Matched image on line ${lineNumber}`);
                        const currentFrom = imageMatch[1];
                        const dep = (0, extract_1.getDep)(currentFrom);
                        dep.depType = 'image';
                        deps.push(dep);
                    }
                }
            }
            const services = /^\s*services:\s*$/.test(line);
            if (services) {
                logger_1.logger.trace(`Matched services on line ${lineNumber}`);
                let foundImage;
                do {
                    foundImage = false;
                    const serviceImageLine = skipCommentLines(lines, lineNumber + 1);
                    logger_1.logger.trace(`serviceImageLine: "${serviceImageLine.line}"`);
                    const serviceImageMatch = /^\s*-\s*(?:name:\s*)?'?"?([^\s'"]+)'?"?\s*$/.exec(serviceImageLine.line);
                    if (serviceImageMatch) {
                        logger_1.logger.trace('serviceImageMatch');
                        foundImage = true;
                        const currentFrom = serviceImageMatch[1];
                        lineNumber = serviceImageLine.lineNumber;
                        const dep = (0, extract_1.getDep)(currentFrom);
                        dep.depType = 'service-image';
                        deps.push(dep);
                    }
                } while (foundImage);
            }
        }
    }
    catch (err) /* istanbul ignore next */ {
        logger_1.logger.warn({ err }, 'Error extracting GitLab CI dependencies');
    }
    if (!deps.length) {
        return null;
    }
    return { deps };
}
exports.extractPackageFile = extractPackageFile;
async function extractAllPackageFiles(_config, packageFiles) {
    const filesToExamine = [...packageFiles];
    const seen = new Set(packageFiles);
    const results = [];
    // extract all includes from the files
    while (filesToExamine.length > 0) {
        const file = filesToExamine.pop();
        const content = await (0, fs_1.readLocalFile)(file, 'utf8');
        if (!content) {
            logger_1.logger.debug({ file }, 'Empty or non existent gitlabci file');
            // eslint-disable-next-line no-continue
            continue;
        }
        let doc;
        try {
            doc = (0, js_yaml_1.load)((0, utils_1.replaceReferenceTags)(content), {
                json: true,
            });
        }
        catch (err) {
            logger_1.logger.warn({ err, file }, 'Error extracting GitLab CI dependencies');
        }
        if (is_1.default.array(doc === null || doc === void 0 ? void 0 : doc.include)) {
            for (const includeObj of doc.include) {
                if (is_1.default.string(includeObj.local)) {
                    const fileObj = includeObj.local.replace(/^\//, '');
                    if (!seen.has(fileObj)) {
                        seen.add(fileObj);
                        filesToExamine.push(fileObj);
                    }
                }
            }
        }
        else if (is_1.default.string(doc === null || doc === void 0 ? void 0 : doc.include)) {
            const fileObj = doc.include.replace(/^\//, '');
            if (!seen.has(fileObj)) {
                seen.add(fileObj);
                filesToExamine.push(fileObj);
            }
        }
        const result = extractPackageFile(content);
        if (result !== null) {
            results.push({
                packageFile: file,
                deps: result.deps,
            });
        }
    }
    logger_1.logger.trace({ packageFiles, files: filesToExamine.entries() }, 'extracted all GitLab CI files');
    if (!results.length) {
        return null;
    }
    return results;
}
exports.extractAllPackageFiles = extractAllPackageFiles;
//# sourceMappingURL=extract.js.map