"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractPackageFile = exports.defaultConfig = exports.language = void 0;
const moo_1 = __importDefault(require("moo"));
const languages_1 = require("../../constants/languages");
const nuget_1 = require("../../datasource/nuget");
const types_1 = require("../../types");
exports.language = languages_1.LANGUAGE_DOT_NET;
exports.defaultConfig = {
    fileMatch: ['\\.cake$'],
};
const lexer = moo_1.default.states({
    main: {
        lineComment: { match: /\/\/.*?$/ },
        multiLineComment: { match: /\/\*[^]*?\*\//, lineBreaks: true },
        dependency: {
            match: /^#(?:addin|tool|module|load|l)\s+(?:nuget|dotnet):.*$/,
        },
        dependencyQuoted: {
            match: /^#(?:addin|tool|module|load|l)\s+"(?:nuget|dotnet):[^"]+"\s*$/,
            value: (s) => s.trim().slice(1, -1),
        },
        unknown: moo_1.default.fallback,
    },
});
function parseDependencyLine(line) {
    try {
        let url = line.replace(/^[^:]*:/, '');
        const isEmptyHost = url.startsWith('?');
        url = isEmptyHost ? `http://localhost/${url}` : url;
        const { origin: registryUrl, protocol, searchParams } = new URL(url);
        const depName = searchParams.get('package');
        const currentValue = searchParams.get('version');
        const result = { datasource: nuget_1.id, depName, currentValue };
        if (!isEmptyHost) {
            if (protocol.startsWith('http')) {
                result.registryUrls = [registryUrl];
            }
            else {
                result.skipReason = types_1.SkipReason.UnsupportedUrl;
            }
        }
        return result;
    }
    catch (err) {
        return null;
    }
}
function extractPackageFile(content) {
    const deps = [];
    lexer.reset(content);
    let token = lexer.next();
    while (token) {
        const { type, value } = token;
        if (type === 'dependency' || type === 'dependencyQuoted') {
            const dep = parseDependencyLine(value);
            if (dep) {
                deps.push(dep);
            }
        }
        token = lexer.next();
    }
    return { deps };
}
exports.extractPackageFile = extractPackageFile;
//# sourceMappingURL=index.js.map