"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getReleases = exports.registryStrategy = exports.defaultVersioning = exports.defaultRegistryUrls = exports.customRegistrySupport = exports.id = void 0;
const p_all_1 = __importDefault(require("p-all"));
const logger_1 = require("../../logger");
const packageCache = __importStar(require("../../util/cache/package"));
const maven_1 = __importDefault(require("../../versioning/maven"));
const mavenVersioning = __importStar(require("../../versioning/maven"));
const compare_1 = require("../../versioning/maven/compare");
const common_1 = require("./common");
const util_1 = require("./util");
var common_2 = require("./common");
Object.defineProperty(exports, "id", { enumerable: true, get: function () { return common_2.id; } });
exports.customRegistrySupport = true;
exports.defaultRegistryUrls = [common_1.MAVEN_REPO];
exports.defaultVersioning = mavenVersioning.id;
exports.registryStrategy = 'merge';
function isStableVersion(x) {
    return maven_1.default.isStable(x);
}
function getLatestStableVersion(releases) {
    const stableVersions = releases
        .map(({ version }) => version)
        .filter(isStableVersion);
    if (stableVersions.length) {
        return stableVersions.reduce((latestVersion, version) => (0, compare_1.compare)(version, latestVersion) === 1 ? version : latestVersion);
    }
    return null;
}
function extractVersions(metadata) {
    const versions = metadata.descendantWithPath('versioning.versions');
    const elements = versions === null || versions === void 0 ? void 0 : versions.childrenNamed('version');
    if (!elements) {
        return [];
    }
    return elements.map((el) => el.val);
}
async function getVersionsFromMetadata(dependency, repoUrl) {
    const metadataUrl = (0, util_1.getMavenUrl)(dependency, repoUrl, 'maven-metadata.xml');
    const cacheNamespace = 'datasource-maven-metadata';
    const cacheKey = metadataUrl.toString();
    const cachedVersions = await packageCache.get(cacheNamespace, cacheKey);
    /* istanbul ignore if */
    if (cachedVersions) {
        return cachedVersions;
    }
    const { authorization, xml: mavenMetadata } = await (0, util_1.downloadMavenXml)(metadataUrl);
    if (!mavenMetadata) {
        return null;
    }
    const versions = extractVersions(mavenMetadata);
    if (!authorization) {
        await packageCache.set(cacheNamespace, cacheKey, versions, 30);
    }
    return versions;
}
// istanbul ignore next
function isValidArtifactsInfo(info, versions) {
    if (!info) {
        return false;
    }
    return versions.every((v) => info[v] !== undefined);
}
async function filterMissingArtifacts(dependency, repoUrl, versions) {
    const cacheNamespace = 'datasource-maven-metadata';
    const cacheKey = `${repoUrl}${dependency.dependencyUrl}`;
    let artifactsInfo = await packageCache.get(cacheNamespace, cacheKey);
    if (!isValidArtifactsInfo(artifactsInfo, versions)) {
        const queue = versions
            .map((version) => {
            const artifactUrl = (0, util_1.getMavenUrl)(dependency, repoUrl, `${version}/${dependency.name}-${version}.pom`);
            return [version, artifactUrl];
        })
            .filter(([_, artifactUrl]) => Boolean(artifactUrl))
            .map(([version, artifactUrl]) => async () => [version, await (0, util_1.isHttpResourceExists)(artifactUrl)]);
        const results = await (0, p_all_1.default)(queue, { concurrency: 5 });
        artifactsInfo = results.reduce((acc, [key, value]) => ({
            ...acc,
            [key]: value,
        }), {});
        // Retry earlier for status other than 404
        const cacheTTL = Object.values(artifactsInfo).some((x) => x === null)
            ? 60
            : 24 * 60;
        await packageCache.set(cacheNamespace, cacheKey, artifactsInfo, cacheTTL);
    }
    return versions
        .filter((v) => artifactsInfo[v])
        .map((version) => {
        const release = { version };
        const releaseTimestamp = artifactsInfo[version];
        if (releaseTimestamp && typeof releaseTimestamp === 'string') {
            release.releaseTimestamp = releaseTimestamp;
        }
        return release;
    });
}
async function getReleases({ lookupName, registryUrl, }) {
    const dependency = (0, util_1.getDependencyParts)(lookupName);
    let releases = null;
    const repoForVersions = {};
    const repoUrl = registryUrl.replace(/\/?$/, '/');
    logger_1.logger.debug(`Looking up ${dependency.display} in repository ${repoUrl}`);
    const metadataVersions = await getVersionsFromMetadata(dependency, repoUrl);
    if (metadataVersions) {
        if (!process.env.RENOVATE_EXPERIMENTAL_NO_MAVEN_POM_CHECK) {
            releases = await filterMissingArtifacts(dependency, repoUrl, metadataVersions);
        }
        /* istanbul ignore next */
        releases = releases || metadataVersions.map((version) => ({ version }));
        const latestVersion = getLatestStableVersion(releases);
        if (latestVersion) {
            repoForVersions[latestVersion] = repoUrl;
        }
        logger_1.logger.debug(`Found ${releases.length} new releases for ${dependency.display} in repository ${repoUrl}`); // prettier-ignore
    }
    if (!(releases === null || releases === void 0 ? void 0 : releases.length)) {
        return null;
    }
    let dependencyInfo = {};
    const latestVersion = getLatestStableVersion(releases);
    if (latestVersion) {
        dependencyInfo = await (0, util_1.getDependencyInfo)(dependency, repoForVersions[latestVersion], latestVersion);
    }
    return {
        ...dependency,
        ...dependencyInfo,
        releases,
    };
}
exports.getReleases = getReleases;
//# sourceMappingURL=index.js.map