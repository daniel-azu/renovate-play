"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TerraformProviderDatasource = void 0;
const p_map_1 = __importDefault(require("p-map"));
const logger_1 = require("../../logger");
const external_host_error_1 = require("../../types/errors/external-host-error");
const decorator_1 = require("../../util/cache/package/decorator");
const url_1 = require("../../util/url");
const hashicorpVersioning = __importStar(require("../../versioning/hashicorp"));
const base_1 = require("../terraform-module/base");
class TerraformProviderDatasource extends base_1.TerraformDatasource {
    constructor() {
        super(TerraformProviderDatasource.id);
        this.defaultRegistryUrls = TerraformProviderDatasource.defaultRegistryUrls;
        this.defaultVersioning = hashicorpVersioning.id;
        this.registryStrategy = 'hunt';
    }
    async getReleases({ lookupName, registryUrl, }) {
        logger_1.logger.debug({ lookupName }, 'terraform-provider.getDependencies()');
        let dep = null;
        const registryHost = (0, url_1.parseUrl)(registryUrl).host;
        if (registryHost === 'releases.hashicorp.com') {
            dep = await this.queryReleaseBackend(lookupName, registryUrl);
        }
        else {
            const repository = TerraformProviderDatasource.getRepository({
                lookupName,
            });
            dep = await this.queryRegistry(registryUrl, repository);
        }
        return dep;
    }
    static getRepository({ lookupName }) {
        return lookupName.includes('/') ? lookupName : `hashicorp/${lookupName}`;
    }
    async queryRegistry(registryURL, repository) {
        const serviceDiscovery = await this.getTerraformServiceDiscoveryResult(registryURL);
        const backendURL = `${registryURL}${serviceDiscovery['providers.v1']}${repository}`;
        const res = (await this.http.getJson(backendURL)).body;
        const dep = {
            releases: null,
        };
        if (res.source) {
            dep.sourceUrl = res.source;
        }
        dep.releases = res.versions.map((version) => ({
            version,
        }));
        // set published date for latest release
        const latestVersion = dep.releases.find((release) => res.version === release.version);
        // istanbul ignore else
        if (latestVersion) {
            latestVersion.releaseTimestamp = res.published_at;
        }
        dep.homepage = `${registryURL}/providers/${repository}`;
        logger_1.logger.trace({ dep }, 'dep');
        return dep;
    }
    // TODO: add long term cache (#9590)
    async queryReleaseBackend(lookupName, registryURL) {
        const backendLookUpName = `terraform-provider-${lookupName}`;
        const backendURL = registryURL + `/index.json`;
        const res = (await this.http.getJson(backendURL)).body;
        if (!res[backendLookUpName]) {
            return null;
        }
        const dep = {
            releases: null,
            sourceUrl: `https://github.com/terraform-providers/${backendLookUpName}`,
        };
        dep.releases = Object.keys(res[backendLookUpName].versions).map((version) => ({
            version,
        }));
        logger_1.logger.trace({ dep }, 'dep');
        return dep;
    }
    async getBuilds(registryURL, repository, version) {
        if (registryURL === TerraformProviderDatasource.defaultRegistryUrls[1]) {
            // check if registryURL === secondary backend
            const repositoryRegexResult = TerraformProviderDatasource.repositoryRegex.exec(repository);
            if (!repositoryRegexResult) {
                // non hashicorp builds are not supported with releases.hashicorp.com
                return null;
            }
            const lookupName = repositoryRegexResult.groups.lookupName;
            const backendLookUpName = `terraform-provider-${lookupName}`;
            let versionReleaseBackend;
            try {
                versionReleaseBackend = await this.getReleaseBackendIndex(backendLookUpName, version);
            }
            catch (err) {
                /* istanbul ignore next */
                if (err instanceof external_host_error_1.ExternalHostError) {
                    throw err;
                }
                logger_1.logger.debug({ err, backendLookUpName, version }, `Failed to retrieve builds for ${backendLookUpName} ${version}`);
                return null;
            }
            return versionReleaseBackend.builds;
        }
        // check public or private Terraform registry
        const serviceDiscovery = await this.getTerraformServiceDiscoveryResult(registryURL);
        if (!serviceDiscovery) {
            logger_1.logger.trace(`Failed to retrieve service discovery from ${registryURL}`);
            return null;
        }
        const backendURL = `${registryURL}${serviceDiscovery['providers.v1']}${repository}`;
        const versionsResponse = (await this.http.getJson(`${backendURL}/versions`)).body;
        if (!versionsResponse.versions) {
            logger_1.logger.trace(`Failed to retrieve version list for ${backendURL}`);
            return null;
        }
        const builds = versionsResponse.versions.find((value) => value.version === version);
        if (!builds) {
            logger_1.logger.trace(`No builds found for ${repository}:${version} on ${registryURL}`);
            return null;
        }
        const result = await (0, p_map_1.default)(builds.platforms, async (platform) => {
            const buildURL = `${backendURL}/${version}/download/${platform.os}/${platform.arch}`;
            try {
                const res = (await this.http.getJson(buildURL)).body;
                const newBuild = {
                    name: repository,
                    url: res.download_url,
                    version,
                    ...res,
                };
                return newBuild;
            }
            catch (err) {
                /* istanbul ignore next */
                if (err instanceof external_host_error_1.ExternalHostError) {
                    throw err;
                }
                logger_1.logger.debug({ err, url: buildURL }, 'Failed to retrieve build');
                return null;
            }
        }, { concurrency: 4 });
        // if any of the requests to build details have failed, return null
        if (result.some((value) => Boolean(value) === false)) {
            return null;
        }
        return result;
    }
    async getReleaseBackendIndex(backendLookUpName, version) {
        return (await this.http.getJson(`${TerraformProviderDatasource.defaultRegistryUrls[1]}/${backendLookUpName}/${version}/index.json`)).body;
    }
}
TerraformProviderDatasource.id = 'terraform-provider';
TerraformProviderDatasource.defaultRegistryUrls = [
    'https://registry.terraform.io',
    'https://releases.hashicorp.com',
];
TerraformProviderDatasource.repositoryRegex = /^hashicorp\/(?<lookupName>\S+)$/;
__decorate([
    (0, decorator_1.cache)({
        namespace: `datasource-${TerraformProviderDatasource.id}`,
        key: (getReleasesConfig) => `${getReleasesConfig.registryUrl}/${TerraformProviderDatasource.getRepository(getReleasesConfig)}`,
    })
], TerraformProviderDatasource.prototype, "getReleases", null);
__decorate([
    (0, decorator_1.cache)({
        namespace: `datasource-${TerraformProviderDatasource.id}-builds`,
        key: (registryURL, repository, version) => `${registryURL}/${repository}/${version}`,
    })
], TerraformProviderDatasource.prototype, "getBuilds", null);
__decorate([
    (0, decorator_1.cache)({
        namespace: `datasource-${TerraformProviderDatasource.id}-releaseBackendIndex`,
        key: (backendLookUpName, version) => `${backendLookUpName}/${version}`,
    })
], TerraformProviderDatasource.prototype, "getReleaseBackendIndex", null);
exports.TerraformProviderDatasource = TerraformProviderDatasource;
//# sourceMappingURL=index.js.map