"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDependency = exports.getDependencyFallback = void 0;
const logger_1 = require("../../logger");
const types_1 = require("../../util/http/types");
const common_1 = require("./common");
const INFO_PATH = '/api/v1/gems';
const VERSIONS_PATH = '/api/v1/versions';
const DEPENDENCIES_PATH = '/api/v1/dependencies';
async function getDependencyFallback(dependency, registry) {
    logger_1.logger.debug({ dependency, api: DEPENDENCIES_PATH }, 'RubyGems lookup for dependency');
    const info = await (0, common_1.fetchBuffer)(dependency, registry, DEPENDENCIES_PATH);
    if (!info || info.length === 0) {
        return null;
    }
    const releases = info.map(({ number: version, platform: rubyPlatform }) => ({
        version,
        rubyPlatform,
    }));
    return {
        releases,
        homepage: null,
        sourceUrl: null,
        changelogUrl: null,
    };
}
exports.getDependencyFallback = getDependencyFallback;
async function getDependency(dependency, registry) {
    var _a;
    logger_1.logger.debug({ dependency, api: INFO_PATH }, 'RubyGems lookup for dependency');
    let info;
    try {
        info = await (0, common_1.fetchJson)(dependency, registry, INFO_PATH);
    }
    catch (error) {
        // fallback to deps api on 404
        if (error instanceof types_1.HttpError && ((_a = error.response) === null || _a === void 0 ? void 0 : _a.statusCode) === 404) {
            return await getDependencyFallback(dependency, registry);
        }
        throw error;
    }
    if (!info) {
        logger_1.logger.debug({ dependency }, 'RubyGems package not found.');
        return null;
    }
    if (dependency.toLowerCase() !== info.name.toLowerCase()) {
        logger_1.logger.warn({ lookup: dependency, returned: info.name }, 'Lookup name does not match with returned.');
        return null;
    }
    let versions = [];
    let releases = [];
    try {
        versions = await (0, common_1.fetchJson)(dependency, registry, VERSIONS_PATH);
    }
    catch (err) {
        if (err.statusCode === 400 || err.statusCode === 404) {
            logger_1.logger.debug({ registry }, 'versions endpoint returns error - falling back to info endpoint');
        }
        else {
            throw err;
        }
    }
    // TODO: invalid properties for `Release` see #11312
    if (versions.length === 0 && info.version) {
        logger_1.logger.warn('falling back to the version from the info endpoint');
        releases = [
            {
                version: info.version,
                rubyPlatform: info.platform,
            },
        ];
    }
    else {
        releases = versions.map(({ number: version, platform: rubyPlatform, created_at: releaseTimestamp, rubygems_version: rubygemsVersion, ruby_version: rubyVersion, }) => ({
            version,
            rubyPlatform,
            releaseTimestamp,
            rubygemsVersion,
            rubyVersion,
        }));
    }
    return {
        releases,
        homepage: info.homepage_uri,
        sourceUrl: info.source_code_uri,
        changelogUrl: info.changelog_uri,
    };
}
exports.getDependency = getDependency;
//# sourceMappingURL=get.js.map