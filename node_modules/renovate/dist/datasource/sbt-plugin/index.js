"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getReleases = exports.registryStrategy = exports.defaultVersioning = exports.defaultRegistryUrls = exports.customRegistrySupport = exports.id = void 0;
const logger_1 = require("../../logger");
const ivyVersioning = __importStar(require("../../versioning/ivy"));
const compare_1 = require("../../versioning/maven/compare");
const util_1 = require("../maven/util");
const sbt_package_1 = require("../sbt-package");
const util_2 = require("./util");
exports.id = 'sbt-plugin';
exports.customRegistrySupport = true;
exports.defaultRegistryUrls = [util_2.SBT_PLUGINS_REPO];
exports.defaultVersioning = ivyVersioning.id;
exports.registryStrategy = 'hunt';
const ensureTrailingSlash = (str) => str.replace(/\/?$/, '/');
async function resolvePluginReleases(rootUrl, artifact, scalaVersion) {
    const searchRoot = `${rootUrl}/${artifact}`;
    const parse = (content) => (0, util_2.parseIndexDir)(content, (x) => !/^\.+$/.test(x));
    const { body: indexContent } = await (0, util_1.downloadHttpProtocol)(ensureTrailingSlash(searchRoot), 'sbt');
    if (indexContent) {
        const releases = [];
        const scalaVersionItems = parse(indexContent);
        const scalaVersions = scalaVersionItems.map((x) => x.replace(/^scala_/, ''));
        const searchVersions = scalaVersions.includes(scalaVersion)
            ? [scalaVersion]
            : scalaVersions;
        for (const searchVersion of searchVersions) {
            const searchSubRoot = `${searchRoot}/scala_${searchVersion}`;
            const { body: subRootContent } = await (0, util_1.downloadHttpProtocol)(ensureTrailingSlash(searchSubRoot), 'sbt');
            if (subRootContent) {
                const sbtVersionItems = parse(subRootContent);
                for (const sbtItem of sbtVersionItems) {
                    const releasesRoot = `${searchSubRoot}/${sbtItem}`;
                    const { body: releasesIndexContent } = await (0, util_1.downloadHttpProtocol)(ensureTrailingSlash(releasesRoot), 'sbt');
                    if (releasesIndexContent) {
                        const releasesParsed = parse(releasesIndexContent);
                        releasesParsed.forEach((x) => releases.push(x));
                    }
                }
            }
        }
        if (releases.length) {
            return [...new Set(releases)].sort(compare_1.compare);
        }
    }
    return null;
}
async function getReleases({ lookupName, registryUrl, }) {
    const [groupId, artifactId] = lookupName.split(':');
    const groupIdSplit = groupId.split('.');
    const artifactIdSplit = artifactId.split('_');
    const [artifact, scalaVersion] = artifactIdSplit;
    const repoRoot = ensureTrailingSlash(registryUrl);
    const searchRoots = [];
    // Optimize lookup order
    searchRoots.push(`${repoRoot}${groupIdSplit.join('.')}`);
    searchRoots.push(`${repoRoot}${groupIdSplit.join('/')}`);
    for (let idx = 0; idx < searchRoots.length; idx += 1) {
        const searchRoot = searchRoots[idx];
        let versions = await resolvePluginReleases(searchRoot, artifact, scalaVersion);
        let urls = {};
        if (!(versions === null || versions === void 0 ? void 0 : versions.length)) {
            const artifactSubdirs = await (0, sbt_package_1.getArtifactSubdirs)(searchRoot, artifact, scalaVersion);
            versions = await (0, sbt_package_1.getPackageReleases)(searchRoot, artifactSubdirs);
            const latestVersion = (0, sbt_package_1.getLatestVersion)(versions);
            urls = await (0, sbt_package_1.getUrls)(searchRoot, artifactSubdirs, latestVersion);
        }
        const dependencyUrl = `${searchRoot}/${artifact}`;
        if (versions) {
            return {
                ...urls,
                dependencyUrl,
                releases: versions.map((v) => ({ version: v })),
            };
        }
    }
    logger_1.logger.debug(`No versions found for ${lookupName} in ${searchRoots.length} repositories`);
    return null;
}
exports.getReleases = getReleases;
//# sourceMappingURL=index.js.map