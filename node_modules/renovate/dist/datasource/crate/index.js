"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getReleases = exports.areReleasesCacheable = exports.fetchCrateRecordsPayload = exports.getIndexSuffix = exports.registryStrategy = exports.defaultVersioning = exports.defaultRegistryUrls = exports.customRegistrySupport = exports.id = void 0;
const hasha_1 = __importDefault(require("hasha"));
const simple_git_1 = __importDefault(require("simple-git"));
const upath_1 = require("upath");
const global_1 = require("../../config/global");
const logger_1 = require("../../logger");
const external_host_error_1 = require("../../types/errors/external-host-error");
const memCache = __importStar(require("../../util/cache/memory"));
const packageCache = __importStar(require("../../util/cache/package"));
const fs_1 = require("../../util/fs");
const http_1 = require("../../util/http");
const cargoVersioning = __importStar(require("../../versioning/cargo"));
const types_1 = require("./types");
exports.id = 'crate';
exports.customRegistrySupport = true;
exports.defaultRegistryUrls = ['https://crates.io'];
exports.defaultVersioning = cargoVersioning.id;
exports.registryStrategy = 'first';
const http = new http_1.Http(exports.id);
const CRATES_IO_BASE_URL = 'https://raw.githubusercontent.com/rust-lang/crates.io-index/master/';
function getIndexSuffix(lookupName) {
    const len = lookupName.length;
    if (len === 1) {
        return ['1', lookupName];
    }
    if (len === 2) {
        return ['2', lookupName];
    }
    if (len === 3) {
        return ['3', lookupName[0], lookupName];
    }
    return [lookupName.slice(0, 2), lookupName.slice(2, 4), lookupName];
}
exports.getIndexSuffix = getIndexSuffix;
async function fetchCrateRecordsPayload(info, lookupName) {
    if (info.clonePath) {
        const path = (0, upath_1.join)(info.clonePath, ...getIndexSuffix(lookupName));
        return (0, fs_1.readFile)(path, 'utf8');
    }
    if (info.flavor === types_1.RegistryFlavor.CratesIo) {
        const crateUrl = CRATES_IO_BASE_URL + getIndexSuffix(lookupName).join('/');
        try {
            return (await http.get(crateUrl)).body;
        }
        catch (err) {
            if (err.statusCode === 429 ||
                (err.statusCode >= 500 && err.statusCode < 600)) {
                throw new external_host_error_1.ExternalHostError(err);
            }
            throw err;
        }
    }
    throw new Error(`unsupported crate registry flavor: ${info.flavor}`);
}
exports.fetchCrateRecordsPayload = fetchCrateRecordsPayload;
/**
 * Computes the dependency URL for a crate, given
 * registry information
 */
function getDependencyUrl(info, lookupName) {
    switch (info.flavor) {
        case types_1.RegistryFlavor.CratesIo:
            return `https://crates.io/crates/${lookupName}`;
        case types_1.RegistryFlavor.Cloudsmith: {
            // input: https://dl.cloudsmith.io/basic/$org/$repo/cargo/index.git
            const tokens = info.url.pathname.split('/');
            const org = tokens[2];
            const repo = tokens[3];
            return `https://cloudsmith.io/~${org}/repos/${repo}/packages/detail/cargo/${lookupName}`;
        }
        default:
            return `${info.rawUrl}/${lookupName}`;
    }
}
/**
 * Given a Git URL, computes a semi-human-readable name for a folder in which to
 * clone the repository.
 */
function cacheDirFromUrl(url) {
    const proto = url.protocol.replace(/:$/, '');
    const host = url.hostname;
    const hash = (0, hasha_1.default)(url.pathname, {
        algorithm: 'sha256',
    }).substr(0, 7);
    return `crate-registry-${proto}-${host}-${hash}`;
}
/**
 * Fetches information about a registry, by url.
 * If no url is given, assumes crates.io.
 * If an url is given, assumes it's a valid Git repository
 * url and clones it to cache.
 */
async function fetchRegistryInfo(config, registryUrl) {
    let url;
    try {
        url = new URL(registryUrl);
    }
    catch (err) {
        logger_1.logger.debug({ registryUrl }, 'could not parse registry URL');
        return null;
    }
    let flavor;
    if (url.hostname === 'crates.io') {
        flavor = types_1.RegistryFlavor.CratesIo;
    }
    else if (url.hostname === 'dl.cloudsmith.io') {
        flavor = types_1.RegistryFlavor.Cloudsmith;
    }
    else {
        flavor = types_1.RegistryFlavor.Other;
    }
    const registry = {
        flavor,
        rawUrl: registryUrl,
        url,
    };
    if (flavor !== types_1.RegistryFlavor.CratesIo) {
        if (!(0, global_1.getGlobalConfig)().allowCustomCrateRegistries) {
            logger_1.logger.warn('crate datasource: allowCustomCrateRegistries=true is required for registries other than crates.io, bailing out');
            return null;
        }
        const cacheKey = `crate-datasource/registry-clone-path/${registryUrl}`;
        const cacheKeyForError = `crate-datasource/registry-clone-path/${registryUrl}/error`;
        // We need to ensure we don't run `git clone` in parallel. Therefore we store
        // a promise of the running operation in the mem cache, which in the end resolves
        // to the file path of the cloned repository.
        const clonePathPromise = memCache.get(cacheKey);
        let clonePath;
        // eslint-disable-next-line @typescript-eslint/no-misused-promises
        if (clonePathPromise) {
            clonePath = await clonePathPromise;
        }
        else {
            clonePath = (0, upath_1.join)((0, fs_1.privateCacheDir)(), cacheDirFromUrl(url));
            logger_1.logger.info({ clonePath, registryUrl }, `Cloning private cargo registry`);
            const git = (0, simple_git_1.default)();
            const clonePromise = git.clone(registryUrl, clonePath, {
                '--depth': 1,
            });
            memCache.set(cacheKey, clonePromise.then(() => clonePath).catch(() => null));
            try {
                await clonePromise;
            }
            catch (err) {
                logger_1.logger.warn({ err, lookupName: config.lookupName, registryUrl }, 'failed cloning git registry');
                memCache.set(cacheKeyForError, err);
                return null;
            }
        }
        if (!clonePath) {
            const err = memCache.get(cacheKeyForError);
            logger_1.logger.warn({ err, lookupName: config.lookupName, registryUrl }, 'Previous git clone failed, bailing out.');
            return null;
        }
        registry.clonePath = clonePath;
    }
    return registry;
}
function areReleasesCacheable(registryUrl) {
    // We only cache public releases, we don't want to cache private
    // cloned data between runs.
    return registryUrl === 'https://crates.io';
}
exports.areReleasesCacheable = areReleasesCacheable;
async function getReleases(config) {
    const { lookupName, registryUrl } = config;
    // istanbul ignore if
    if (!registryUrl) {
        logger_1.logger.warn('crate datasource: No registryUrl specified, cannot perform getReleases');
        return null;
    }
    const cacheable = areReleasesCacheable(registryUrl);
    const cacheNamespace = 'datasource-crate';
    const cacheKey = `${registryUrl}/${lookupName}`;
    if (cacheable) {
        const cachedResult = await packageCache.get(cacheNamespace, cacheKey);
        // istanbul ignore if
        if (cachedResult) {
            logger_1.logger.debug({ cacheKey }, 'Returning cached resource');
            return cachedResult;
        }
    }
    const registryInfo = await fetchRegistryInfo(config, registryUrl);
    if (!registryInfo) {
        logger_1.logger.debug({ registryUrl }, 'Could not fetch registry info');
        return null;
    }
    const dependencyUrl = getDependencyUrl(registryInfo, lookupName);
    const payload = await fetchCrateRecordsPayload(registryInfo, lookupName);
    const lines = payload
        .split('\n') // break into lines
        .map((line) => line.trim()) // remove whitespace
        .filter((line) => line.length !== 0) // remove empty lines
        .map((line) => JSON.parse(line)); // parse
    const result = {
        dependencyUrl,
        releases: [],
    };
    result.releases = lines
        .map((version) => {
        const release = {
            version: version.vers,
        };
        if (version.yanked) {
            release.isDeprecated = true;
        }
        return release;
    })
        .filter((release) => release.version);
    if (!result.releases.length) {
        return null;
    }
    if (cacheable) {
        const cacheMinutes = 10;
        await packageCache.set(cacheNamespace, cacheKey, result, cacheMinutes);
    }
    return result;
}
exports.getReleases = getReleases;
//# sourceMappingURL=index.js.map