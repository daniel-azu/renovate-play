"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDependency = exports.resetCache = exports.resetMemCache = void 0;
const url_1 = __importDefault(require("url"));
const is_1 = __importDefault(require("@sindresorhus/is"));
const logger_1 = require("../../logger");
const external_host_error_1 = require("../../types/errors/external-host-error");
const packageCache = __importStar(require("../../util/cache/package"));
const http_1 = require("../../util/http");
const common_1 = require("./common");
const npmrc_1 = require("./npmrc");
const http = new http_1.Http(common_1.id);
let memcache = {};
function resetMemCache() {
    logger_1.logger.debug('resetMemCache()');
    memcache = {};
}
exports.resetMemCache = resetMemCache;
function resetCache() {
    resetMemCache();
}
exports.resetCache = resetCache;
async function getDependency(packageName) {
    var _a;
    logger_1.logger.trace(`npm.getDependency(${packageName})`);
    // This is our datastore cache and is cleared at the end of each repo, i.e. we never requery/revalidate during a "run"
    if (memcache[packageName]) {
        logger_1.logger.trace('Returning cached result');
        return JSON.parse(memcache[packageName]);
    }
    const { headers, packageUrl, registryUrl } = (0, npmrc_1.resolvePackage)(packageName);
    // Now check the persistent cache
    const cacheNamespace = 'datasource-npm';
    const cachedResult = await packageCache.get(cacheNamespace, packageUrl);
    // istanbul ignore if
    if (cachedResult) {
        return cachedResult;
    }
    const uri = url_1.default.parse(packageUrl);
    if (uri.host === 'registry.npmjs.org' && !uri.pathname.startsWith('/@')) {
        // Delete the authorization header for non-scoped public packages to improve http caching
        // Otherwise, authenticated requests are not cacheable until the registry adds "public" to Cache-Control
        // Ref: https://greenbytes.de/tech/webdav/rfc7234.html#caching.authenticated.responses
        delete headers.authorization;
    }
    try {
        const opts = {
            headers,
        };
        const raw = await http.getJson(packageUrl, opts);
        const res = raw.body;
        if (!res.versions || !Object.keys(res.versions).length) {
            // Registry returned a 200 OK but with no versions
            logger_1.logger.debug({ dependency: packageName }, 'No versions returned');
            return null;
        }
        const latestVersion = res.versions[res['dist-tags'].latest];
        res.repository = res.repository || latestVersion.repository;
        res.homepage = res.homepage || latestVersion.homepage;
        // Determine repository URL
        let sourceUrl;
        if (res.repository) {
            if (is_1.default.string(res.repository)) {
                sourceUrl = res.repository;
            }
            else if (res.repository.url) {
                sourceUrl = res.repository.url;
            }
        }
        // Simplify response before caching and returning
        const dep = {
            name: res.name,
            homepage: res.homepage,
            sourceUrl,
            versions: {},
            releases: null,
            'dist-tags': res['dist-tags'],
            registryUrl,
        };
        if ((_a = res.repository) === null || _a === void 0 ? void 0 : _a.directory) {
            dep.sourceDirectory = res.repository.directory;
        }
        if (latestVersion.deprecated) {
            dep.deprecationMessage = `On registry \`${registryUrl}\`, the "latest" version of dependency \`${packageName}\` has the following deprecation notice:\n\n\`${latestVersion.deprecated}\`\n\nMarking the latest version of an npm package as deprecated results in the entire package being considered deprecated, so contact the package author you think this is a mistake.`;
            dep.deprecationSource = common_1.id;
        }
        dep.releases = Object.keys(res.versions).map((version) => {
            var _a;
            const release = {
                version,
                gitRef: res.versions[version].gitHead,
                dependencies: res.versions[version].dependencies,
                devDependencies: res.versions[version].devDependencies,
            };
            if ((_a = res.time) === null || _a === void 0 ? void 0 : _a[version]) {
                release.releaseTimestamp = res.time[version];
            }
            if (res.versions[version].deprecated) {
                release.isDeprecated = true;
            }
            return release;
        });
        logger_1.logger.trace({ dep }, 'dep');
        // serialize first before saving
        memcache[packageName] = JSON.stringify(dep);
        const cacheMinutes = process.env.RENOVATE_CACHE_NPM_MINUTES
            ? parseInt(process.env.RENOVATE_CACHE_NPM_MINUTES, 10)
            : 15;
        // TODO: use dynamic detection of public repos instead of a static list (#9587)
        const whitelistedPublicScopes = [
            '@graphql-codegen',
            '@storybook',
            '@types',
            '@typescript-eslint',
        ];
        if (!raw.authorization &&
            (whitelistedPublicScopes.includes(packageName.split('/')[0]) ||
                !packageName.startsWith('@'))) {
            await packageCache.set(cacheNamespace, packageUrl, dep, cacheMinutes);
        }
        return dep;
    }
    catch (err) {
        if (err.statusCode === 401 || err.statusCode === 403) {
            logger_1.logger.debug({
                packageUrl,
                err,
                statusCode: err.statusCode,
                packageName,
            }, `Dependency lookup failure: unauthorized`);
            return null;
        }
        if (err.statusCode === 402) {
            logger_1.logger.debug({
                packageUrl,
                err,
                statusCode: err.statusCode,
                packageName,
            }, `Dependency lookup failure: payent required`);
            return null;
        }
        if (err.statusCode === 404 || err.code === 'ENOTFOUND') {
            logger_1.logger.debug({ err, packageName }, `Dependency lookup failure: not found`);
            return null;
        }
        if (uri.host === 'registry.npmjs.org') {
            // istanbul ignore if
            if (err.name === 'ParseError' && err.body) {
                err.body = 'err.body deleted by Renovate';
            }
            throw new external_host_error_1.ExternalHostError(err);
        }
        return null;
    }
}
exports.getDependency = getDependency;
//# sourceMappingURL=get.js.map