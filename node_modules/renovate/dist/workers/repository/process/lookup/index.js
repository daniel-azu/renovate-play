"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.lookupUpdates = void 0;
const config_1 = require("../../../../config");
const datasource_1 = require("../../../../datasource");
const logger_1 = require("../../../../logger");
const manager_1 = require("../../../../manager");
const types_1 = require("../../../../types");
const clone_1 = require("../../../../util/clone");
const package_rules_1 = require("../../../../util/package-rules");
const allVersioning = __importStar(require("../../../../versioning"));
const bucket_1 = require("./bucket");
const current_1 = require("./current");
const filter_1 = require("./filter");
const filter_checks_1 = require("./filter-checks");
const generate_1 = require("./generate");
const rollback_1 = require("./rollback");
async function lookupUpdates(inconfig) {
    var _a, _b;
    let config = { ...inconfig };
    const { currentDigest, currentValue, datasource, depName, digestOneAndOnly, followTag, lockedVersion, packageFile, pinDigests, rollbackPrs, isVulnerabilityAlert, updatePinnedDependencies, } = config;
    logger_1.logger.trace({ dependency: depName, currentValue }, 'lookupUpdates');
    // Use the datasource's default versioning if none is configured
    (_a = config.versioning) !== null && _a !== void 0 ? _a : (config.versioning = (0, datasource_1.getDefaultVersioning)(datasource));
    const versioning = allVersioning.get(config.versioning);
    const res = {
        updates: [],
        warnings: [],
        versioning: config.versioning,
    };
    // istanbul ignore if
    if (!(0, datasource_1.isGetPkgReleasesConfig)(config) ||
        !(0, datasource_1.getDatasourceList)().includes(datasource)) {
        res.skipReason = types_1.SkipReason.InvalidConfig;
        return res;
    }
    const isValid = currentValue && versioning.isValid(currentValue);
    if (isValid) {
        if (!updatePinnedDependencies && versioning.isSingleVersion(currentValue)) {
            res.skipReason = types_1.SkipReason.IsPinned;
            return res;
        }
        const dependency = (0, clone_1.clone)(await (0, datasource_1.getPkgReleases)(config));
        if (!dependency) {
            // If dependency lookup fails then warn and return
            const warning = {
                topic: depName,
                message: `Failed to look up dependency ${depName}`,
            };
            logger_1.logger.debug({ dependency: depName, packageFile }, warning.message);
            // TODO: return warnings in own field
            res.warnings.push(warning);
            return res;
        }
        if (dependency.deprecationMessage) {
            logger_1.logger.debug({ dependency: depName }, 'Found deprecationMessage');
            res.deprecationMessage = dependency.deprecationMessage;
        }
        res.sourceUrl = dependency === null || dependency === void 0 ? void 0 : dependency.sourceUrl;
        if (dependency.sourceDirectory) {
            res.sourceDirectory = dependency.sourceDirectory;
        }
        res.homepage = dependency.homepage;
        res.changelogUrl = dependency.changelogUrl;
        res.dependencyUrl = dependency === null || dependency === void 0 ? void 0 : dependency.dependencyUrl;
        const latestVersion = (_b = dependency.tags) === null || _b === void 0 ? void 0 : _b.latest;
        // Filter out any results from datasource that don't comply with our versioning
        let allVersions = dependency.releases.filter((release) => versioning.isVersion(release.version));
        // istanbul ignore if
        if (allVersions.length === 0) {
            const message = `Found no results from datasource that look like a version`;
            logger_1.logger.debug({ dependency: depName, result: dependency }, message);
            if (!currentDigest) {
                return res;
            }
        }
        // Reapply package rules in case we missed something from sourceUrl
        config = (0, package_rules_1.applyPackageRules)({ ...config, sourceUrl: res.sourceUrl });
        if (followTag) {
            const taggedVersion = dependency.tags[followTag];
            if (!taggedVersion) {
                res.warnings.push({
                    topic: depName,
                    message: `Can't find version with tag ${followTag} for ${depName}`,
                });
                return res;
            }
            allVersions = allVersions.filter((v) => v.version === taggedVersion ||
                (v.version === currentValue &&
                    versioning.isGreaterThan(taggedVersion, currentValue)));
        }
        // Check that existing constraint can be satisfied
        const allSatisfyingVersions = allVersions.filter((v) => versioning.matches(v.version, currentValue));
        if (rollbackPrs && !allSatisfyingVersions.length) {
            const rollback = (0, rollback_1.getRollbackUpdate)(config, allVersions, versioning);
            // istanbul ignore if
            if (!rollback) {
                res.warnings.push({
                    topic: depName,
                    message: `Can't find version matching ${currentValue} for ${depName}`,
                });
                return res;
            }
            res.updates.push(rollback);
        }
        let rangeStrategy = (0, manager_1.getRangeStrategy)(config);
        // istanbul ignore next
        if (isVulnerabilityAlert &&
            rangeStrategy === 'update-lockfile' &&
            !lockedVersion) {
            rangeStrategy = 'bump';
        }
        const nonDeprecatedVersions = dependency.releases
            .filter((release) => !release.isDeprecated)
            .map((release) => release.version);
        const currentVersion = (0, current_1.getCurrentVersion)(config, versioning, rangeStrategy, latestVersion, nonDeprecatedVersions) ||
            (0, current_1.getCurrentVersion)(config, versioning, rangeStrategy, latestVersion, allVersions.map((v) => v.version));
        // istanbul ignore if
        if (!currentVersion && lockedVersion) {
            return res;
        }
        res.currentVersion = currentVersion;
        if (currentVersion &&
            rangeStrategy === 'pin' &&
            !versioning.isSingleVersion(currentValue)) {
            res.updates.push({
                updateType: 'pin',
                isPin: true,
                newValue: versioning.getNewValue({
                    currentValue,
                    rangeStrategy,
                    currentVersion,
                    newVersion: currentVersion,
                }),
                newMajor: versioning.getMajor(currentVersion),
            });
        }
        let filterStart = currentVersion;
        if (lockedVersion && rangeStrategy === 'update-lockfile') {
            // Look for versions greater than the current locked version that still satisfy the package.json range
            filterStart = lockedVersion;
        }
        // Filter latest, unstable, etc
        let filteredReleases = (0, filter_1.filterVersions)(config, filterStart, latestVersion, allVersions, versioning).filter((v) => 
        // Leave only compatible versions
        versioning.isCompatible(v.version, currentValue));
        if (isVulnerabilityAlert) {
            filteredReleases = filteredReleases.slice(0, 1);
        }
        const buckets = {};
        for (const release of filteredReleases) {
            const bucket = (0, bucket_1.getBucket)(config, currentVersion, release.version, versioning);
            if (buckets[bucket]) {
                buckets[bucket].push(release);
            }
            else {
                buckets[bucket] = [release];
            }
        }
        const depResultConfig = (0, config_1.mergeChildConfig)(config, res);
        for (const [bucket, releases] of Object.entries(buckets)) {
            const sortedReleases = releases.sort((r1, r2) => versioning.sortVersions(r1.version, r2.version));
            const { release, pendingChecks, pendingReleases } = await (0, filter_checks_1.filterInternalChecks)(depResultConfig, versioning, bucket, sortedReleases);
            // istanbul ignore next
            if (!release) {
                return res;
            }
            const newVersion = release.version;
            const update = (0, generate_1.generateUpdate)(config, versioning, rangeStrategy, lockedVersion || currentVersion, bucket, release);
            if (pendingChecks) {
                update.pendingChecks = pendingChecks;
            }
            if (pendingReleases.length) {
                update.pendingVersions = pendingReleases.map((r) => r.version);
            }
            if (!update.newValue || update.newValue === currentValue) {
                if (!lockedVersion) {
                    continue; // eslint-disable-line no-continue
                }
                // istanbul ignore if
                if (rangeStrategy === 'bump') {
                    logger_1.logger.trace({ depName, currentValue, lockedVersion, newVersion }, 'Skipping bump because newValue is the same');
                    continue; // eslint-disable-line no-continue
                }
                res.isSingleVersion = true;
            }
            res.isSingleVersion =
                res.isSingleVersion || !!versioning.isSingleVersion(update.newValue);
            res.updates.push(update);
        }
    }
    else if (currentValue) {
        logger_1.logger.debug(`Dependency ${depName} has unsupported value ${currentValue}`);
        if (!pinDigests && !currentDigest) {
            res.skipReason = types_1.SkipReason.InvalidValue;
        }
        else {
            delete res.skipReason;
        }
    }
    else {
        res.skipReason = types_1.SkipReason.InvalidValue;
    }
    // Record if the dep is fixed to a version
    if (lockedVersion) {
        res.currentVersion = lockedVersion;
        res.fixedVersion = lockedVersion;
    }
    else if (currentValue && versioning.isSingleVersion(currentValue)) {
        res.fixedVersion = currentValue.replace(/^=+/, '');
    }
    // Add digests if necessary
    if ((0, datasource_1.supportsDigests)(config)) {
        if (currentDigest) {
            if (!digestOneAndOnly || !res.updates.length) {
                // digest update
                res.updates.push({
                    updateType: 'digest',
                    newValue: currentValue,
                });
            }
        }
        else if (pinDigests) {
            // Create a pin only if one doesn't already exists
            if (!res.updates.some((update) => update.updateType === 'pin')) {
                // pin digest
                res.updates.push({
                    updateType: 'pin',
                    newValue: currentValue,
                });
            }
        }
        if (versioning.valueToVersion) {
            res.currentVersion = versioning.valueToVersion(res.currentVersion);
            for (const update of res.updates || []) {
                update.newVersion = versioning.valueToVersion(update.newVersion);
            }
        }
        // update digest for all
        for (const update of res.updates) {
            if (pinDigests || currentDigest) {
                update.newDigest =
                    update.newDigest || (await (0, datasource_1.getDigest)(config, update.newValue));
            }
        }
    }
    if (res.updates.length) {
        delete res.skipReason;
    }
    // Strip out any non-changed ones
    res.updates = res.updates
        .filter((update) => update.newDigest !== null)
        .filter((update) => update.newValue !== currentValue ||
        update.isLockfileUpdate ||
        (update.newDigest && !update.newDigest.startsWith(currentDigest)));
    return res;
}
exports.lookupUpdates = lookupUpdates;
//# sourceMappingURL=index.js.map