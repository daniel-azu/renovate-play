"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tryBranchAutomerge = void 0;
const global_1 = require("../../config/global");
const logger_1 = require("../../logger");
const platform_1 = require("../../platform");
const types_1 = require("../../types");
const git_1 = require("../../util/git");
async function tryBranchAutomerge(config) {
    var _a;
    logger_1.logger.debug('Checking if we can automerge branch');
    if (!(config.automerge && config.automergeType === 'branch')) {
        return 'no automerge';
    }
    const existingPr = await platform_1.platform.getBranchPr(config.branchName);
    if (existingPr) {
        return 'automerge aborted - PR exists';
    }
    const branchStatus = await platform_1.platform.getBranchStatus(config.branchName, config.requiredStatusChecks);
    if (branchStatus === types_1.BranchStatus.green) {
        logger_1.logger.debug(`Automerging branch`);
        try {
            if ((0, global_1.getGlobalConfig)().dryRun) {
                logger_1.logger.info('DRY-RUN: Would automerge branch' + config.branchName);
            }
            else {
                await (0, git_1.mergeBranch)(config.branchName);
            }
            logger_1.logger.info({ branch: config.branchName }, 'Branch automerged');
            return 'automerged'; // Branch no longer exists
        }
        catch (err) /* istanbul ignore next */ {
            if (err.message === 'not ready') {
                logger_1.logger.debug('Branch is not ready for automerge');
                return 'not ready';
            }
            if (err.message.includes('refusing to merge unrelated histories') ||
                err.message.includes('Not possible to fast-forward')) {
                logger_1.logger.warn({ err }, 'Branch is not up to date - cannot automerge');
                return 'stale';
            }
            if (err.message.includes('Protected branch')) {
                if (err.message.includes('status check')) {
                    logger_1.logger.debug({ err }, 'Branch is not ready for automerge: required status checks are remaining');
                    return 'not ready';
                }
                if ((_a = err.stack) === null || _a === void 0 ? void 0 : _a.includes('reviewers')) {
                    logger_1.logger.info({ err }, 'Branch automerge is not possible due to branch protection (required reviewers)');
                    return 'failed';
                }
                logger_1.logger.info({ err }, 'Branch automerge is not possible due to branch protection');
                return 'failed';
            }
            logger_1.logger.warn({ err }, 'Unknown error when attempting branch automerge');
            return 'failed';
        }
    }
    else if (branchStatus === types_1.BranchStatus.red) {
        return 'branch status error';
    }
    else {
        logger_1.logger.debug(`Branch status is "${branchStatus}" - skipping automerge`);
    }
    return 'no automerge';
}
exports.tryBranchAutomerge = tryBranchAutomerge;
//# sourceMappingURL=automerge.js.map