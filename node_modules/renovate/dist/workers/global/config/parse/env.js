"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getConfig = exports.getEnvName = void 0;
const is_1 = __importDefault(require("@sindresorhus/is"));
const options_1 = require("../../../../config/options");
const platforms_1 = require("../../../../constants/platforms");
const datasource_1 = require("../../../../datasource");
const logger_1 = require("../../../../logger");
// istanbul ignore if
if (process.env.ENV_PREFIX) {
    for (const [key, val] of Object.entries(process.env)) {
        if (key.startsWith(process.env.ENV_PREFIX)) {
            process.env[key.replace(process.env.ENV_PREFIX, 'RENOVATE_')] = val;
        }
    }
}
function getEnvName(option) {
    if (option.env === false) {
        return '';
    }
    if (option.env) {
        return option.env;
    }
    const nameWithUnderscores = option.name.replace(/([A-Z])/g, '_$1');
    return `RENOVATE_${nameWithUnderscores.toUpperCase()}`;
}
exports.getEnvName = getEnvName;
function getConfig(env) {
    const options = (0, options_1.getOptions)();
    let config = {};
    if (env.RENOVATE_CONFIG) {
        try {
            config = JSON.parse(env.RENOVATE_CONFIG);
            logger_1.logger.debug({ config }, 'Detected config in env RENOVATE_CONFIG');
        }
        catch (err) /* istanbul ignore next */ {
            logger_1.logger.fatal({ err }, 'Could not parse RENOVATE_CONFIG');
            process.exit(1);
        }
    }
    config.hostRules || (config.hostRules = []);
    const coersions = {
        boolean: (val) => val === 'true',
        array: (val) => val.split(',').map((el) => el.trim()),
        string: (val) => val.replace(/\\n/g, '\n'),
        object: (val) => JSON.parse(val),
        integer: parseInt,
    };
    options.forEach((option) => {
        if (option.env !== false) {
            const envName = getEnvName(option);
            if (env[envName]) {
                // istanbul ignore if
                if (option.type === 'array' && option.subType === 'object') {
                    try {
                        const parsed = JSON.parse(env[envName]);
                        if (is_1.default.array(parsed)) {
                            config[option.name] = parsed;
                        }
                        else {
                            logger_1.logger.debug({ val: env[envName], envName }, 'Could not parse object array');
                        }
                    }
                    catch (err) {
                        logger_1.logger.debug({ val: env[envName], envName }, 'Could not parse CLI');
                    }
                }
                else {
                    const coerce = coersions[option.type];
                    config[option.name] = coerce(env[envName]);
                }
            }
        }
    });
    if (env.GITHUB_COM_TOKEN) {
        config.hostRules.push({
            hostType: platforms_1.PLATFORM_TYPE_GITHUB,
            matchHost: 'github.com',
            token: env.GITHUB_COM_TOKEN,
        });
    }
    const datasources = new Set((0, datasource_1.getDatasourceList)());
    const fields = ['token', 'username', 'password'];
    const hostRules = [];
    const npmEnvPrefixes = ['npm_config_', 'npm_lifecycle_', 'npm_package_'];
    for (const envName of Object.keys(env).sort()) {
        if (npmEnvPrefixes.some((prefix) => envName.startsWith(prefix))) {
            logger_1.logger.trace('Ignoring npm env: ' + envName);
            continue; // eslint-disable-line no-continue
        }
        // Double underscore __ is used in place of hyphen -
        const splitEnv = envName.toLowerCase().replace(/__/g, '-').split('_');
        const hostType = splitEnv.shift();
        if (datasources.has(hostType)) {
            const suffix = splitEnv.pop();
            if (fields.includes(suffix)) {
                let matchHost;
                const rule = {};
                rule[suffix] = env[envName];
                if (splitEnv.length === 0) {
                    // host-less rule
                }
                else if (splitEnv.length === 1) {
                    logger_1.logger.warn(`Cannot parse ${envName} env`);
                    continue; // eslint-disable-line no-continue
                }
                else {
                    matchHost = splitEnv.join('.');
                }
                const existingRule = hostRules.find((hr) => hr.hostType === hostType && hr.matchHost === matchHost);
                if (existingRule) {
                    // Add current field to existing rule
                    existingRule[suffix] = env[envName];
                }
                else {
                    // Create a new rule
                    const newRule = {
                        hostType,
                    };
                    if (matchHost) {
                        newRule.matchHost = matchHost;
                    }
                    newRule[suffix] = env[envName];
                    hostRules.push(newRule);
                }
            }
        }
    }
    config.hostRules = [...config.hostRules, ...hostRules];
    // These env vars are deprecated and deleted to make sure they're not used
    const unsupportedEnv = [
        'BITBUCKET_TOKEN',
        'BITBUCKET_USERNAME',
        'BITBUCKET_PASSWORD',
        'GITHUB_ENDPOINT',
        'GITHUB_TOKEN',
        'GITLAB_ENDPOINT',
        'GITLAB_TOKEN',
        'VSTS_ENDPOINT',
        'VSTS_TOKEN',
    ];
    // eslint-disable-next-line no-param-reassign
    unsupportedEnv.forEach((val) => delete env[val]);
    return config;
}
exports.getConfig = getConfig;
//# sourceMappingURL=env.js.map