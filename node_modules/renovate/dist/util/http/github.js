"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GithubHttp = exports.setBaseUrl = void 0;
const is_1 = __importDefault(require("@sindresorhus/is"));
const p_all_1 = __importDefault(require("p-all"));
const parse_link_header_1 = __importDefault(require("parse-link-header"));
const error_messages_1 = require("../../constants/error-messages");
const platforms_1 = require("../../constants/platforms");
const logger_1 = require("../../logger");
const external_host_error_1 = require("../../types/errors/external-host-error");
const mask_1 = require("../mask");
const _1 = require(".");
let baseUrl = 'https://api.github.com/';
const setBaseUrl = (url) => {
    baseUrl = url;
};
exports.setBaseUrl = setBaseUrl;
function handleGotError(err, url, opts) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const path = url.toString();
    let message = err.message || '';
    if (is_1.default.plainObject((_a = err.response) === null || _a === void 0 ? void 0 : _a.body) && 'message' in err.response.body) {
        message = String(err.response.body.message);
    }
    if (err.name === 'RequestError' &&
        (err.code === 'ENOTFOUND' ||
            err.code === 'ETIMEDOUT' ||
            err.code === 'EAI_AGAIN' ||
            err.code === 'ECONNRESET')) {
        logger_1.logger.debug({ err }, 'GitHub failure: RequestError');
        throw new external_host_error_1.ExternalHostError(err, platforms_1.PLATFORM_TYPE_GITHUB);
    }
    if (err.name === 'ParseError') {
        logger_1.logger.debug({ err }, '');
        throw new external_host_error_1.ExternalHostError(err, platforms_1.PLATFORM_TYPE_GITHUB);
    }
    if (err.statusCode >= 500 && err.statusCode < 600) {
        logger_1.logger.debug({ err }, 'GitHub failure: 5xx');
        throw new external_host_error_1.ExternalHostError(err, platforms_1.PLATFORM_TYPE_GITHUB);
    }
    if (err.statusCode === 403 &&
        message.startsWith('You have triggered an abuse detection mechanism')) {
        logger_1.logger.debug({ err }, 'GitHub failure: abuse detection');
        throw new Error(error_messages_1.PLATFORM_RATE_LIMIT_EXCEEDED);
    }
    if (err.statusCode === 403 && message.includes('Upgrade to GitHub Pro')) {
        logger_1.logger.debug({ path }, 'Endpoint needs paid GitHub plan');
        throw err;
    }
    if (err.statusCode === 403 && message.includes('rate limit exceeded')) {
        logger_1.logger.debug({ err }, 'GitHub failure: rate limit');
        throw new Error(error_messages_1.PLATFORM_RATE_LIMIT_EXCEEDED);
    }
    if (err.statusCode === 403 &&
        message.startsWith('Resource not accessible by integration')) {
        logger_1.logger.debug({ err }, 'GitHub failure: Resource not accessible by integration');
        throw new Error(error_messages_1.PLATFORM_INTEGRATION_UNAUTHORIZED);
    }
    if (err.statusCode === 401 && message.includes('Bad credentials')) {
        const rateLimit = (_c = (_b = err.headers) === null || _b === void 0 ? void 0 : _b['x-ratelimit-limit']) !== null && _c !== void 0 ? _c : -1;
        logger_1.logger.debug({
            token: (0, mask_1.maskToken)(opts.token),
            err,
        }, 'GitHub failure: Bad credentials');
        if (rateLimit === '60') {
            throw new external_host_error_1.ExternalHostError(err, platforms_1.PLATFORM_TYPE_GITHUB);
        }
        throw new Error(error_messages_1.PLATFORM_BAD_CREDENTIALS);
    }
    if (err.statusCode === 422) {
        if (message.includes('Review cannot be requested from pull request author')) {
            throw err;
        }
        else if ((_e = (_d = err.body) === null || _d === void 0 ? void 0 : _d.errors) === null || _e === void 0 ? void 0 : _e.find((e) => e.code === 'invalid')) {
            logger_1.logger.debug({ err }, 'Received invalid response - aborting');
            throw new Error(error_messages_1.REPOSITORY_CHANGED);
        }
        else if ((_g = (_f = err.body) === null || _f === void 0 ? void 0 : _f.errors) === null || _g === void 0 ? void 0 : _g.find((e) => { var _a; return (_a = e.message) === null || _a === void 0 ? void 0 : _a.startsWith('A pull request already exists'); })) {
            throw err;
        }
        logger_1.logger.debug({ err }, '422 Error thrown from GitHub');
        throw new external_host_error_1.ExternalHostError(err, platforms_1.PLATFORM_TYPE_GITHUB);
    }
    if (err.statusCode === 410 &&
        ((_h = err.body) === null || _h === void 0 ? void 0 : _h.message) === 'Issues are disabled for this repo') {
        throw err;
    }
    if (err.statusCode === 404) {
        logger_1.logger.debug({ url: path }, 'GitHub 404');
    }
    else {
        logger_1.logger.debug({ err }, 'Unknown GitHub error');
    }
    throw err;
}
function constructAcceptString(input) {
    const defaultAccept = 'application/vnd.github.v3+json';
    const acceptStrings = typeof input === 'string' ? input.split(/\s*,\s*/) : [];
    if (!acceptStrings.some((x) => x.startsWith('application/vnd.github.')) ||
        acceptStrings.length < 2) {
        acceptStrings.push(defaultAccept);
    }
    return acceptStrings.join(', ');
}
class GithubHttp extends _1.Http {
    constructor(hostType = platforms_1.PLATFORM_TYPE_GITHUB, options) {
        super(hostType, options);
    }
    async request(url, options, okToRetry = true) {
        var _a, _b;
        let result = null;
        const opts = {
            baseUrl,
            ...options,
            throwHttpErrors: true,
        };
        const accept = constructAcceptString((_a = opts.headers) === null || _a === void 0 ? void 0 : _a.accept);
        opts.headers = {
            ...opts.headers,
            accept,
        };
        try {
            result = await super.request(url, opts);
            // istanbul ignore else: Can result be null ???
            if (result !== null) {
                if (opts.paginate) {
                    // Check if result is paginated
                    const pageLimit = opts.pageLimit || 10;
                    const linkHeader = ((_b = result === null || result === void 0 ? void 0 : result.headers) === null || _b === void 0 ? void 0 : _b.link) &&
                        (0, parse_link_header_1.default)(result.headers.link);
                    if ((linkHeader === null || linkHeader === void 0 ? void 0 : linkHeader.next) && (linkHeader === null || linkHeader === void 0 ? void 0 : linkHeader.last)) {
                        let lastPage = +linkHeader.last.page;
                        // istanbul ignore else: needs a test
                        if (!process.env.RENOVATE_PAGINATE_ALL && opts.paginate !== 'all') {
                            lastPage = Math.min(pageLimit, lastPage);
                        }
                        const pageNumbers = Array.from(new Array(lastPage), (x, i) => i + 1).slice(1);
                        const queue = pageNumbers.map((page) => () => {
                            const nextUrl = new URL(linkHeader.next.url, baseUrl);
                            delete nextUrl.search;
                            nextUrl.searchParams.set('page', page.toString());
                            return this.request(nextUrl, { ...opts, paginate: false }, okToRetry);
                        });
                        const pages = await (0, p_all_1.default)(queue, { concurrency: 5 });
                        if (opts.paginationField) {
                            result.body[opts.paginationField] = result.body[opts.paginationField].concat(...pages
                                .filter(Boolean)
                                .map((page) => page.body[opts.paginationField]));
                        }
                        else {
                            result.body = result.body.concat(...pages.filter(Boolean).map((page) => page.body));
                        }
                    }
                }
            }
        }
        catch (err) {
            handleGotError(err, url, opts);
        }
        return result;
    }
    async queryRepo(query, options = {}) {
        var _a, _b;
        let result = null;
        const path = 'graphql';
        const { paginate, count = 100, cursor = null } = options;
        let { variables } = options;
        if (paginate) {
            variables = {
                ...variables,
                count,
                cursor,
            };
        }
        const body = variables ? { query, variables } : { query };
        const opts = {
            baseUrl: baseUrl.replace('/v3/', '/'),
            body,
            headers: { accept: options === null || options === void 0 ? void 0 : options.acceptHeader },
        };
        logger_1.logger.trace(`Performing Github GraphQL request`);
        try {
            const res = await this.postJson('graphql', opts);
            result = (_b = (_a = res === null || res === void 0 ? void 0 : res.body) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.repository;
        }
        catch (err) {
            if (err instanceof external_host_error_1.ExternalHostError) {
                const gotError = err.err;
                const statusCode = gotError === null || gotError === void 0 ? void 0 : gotError.statusCode;
                if (count &&
                    count > 10 &&
                    statusCode &&
                    statusCode >= 500 &&
                    statusCode < 600) {
                    logger_1.logger.info('Reducing pagination count to workaround graphql 5xx');
                    return null;
                }
            }
            handleGotError(err, path, opts);
        }
        return result;
    }
    async queryRepoField(query, fieldName, options = {}) {
        const result = [];
        const { paginate = true } = options;
        let count = options.count || 100;
        let limit = options.limit || 1000;
        let cursor = null;
        let isIterating = true;
        while (isIterating) {
            const gqlRes = await this.queryRepo(query, {
                ...options,
                count: Math.min(count, limit),
                cursor,
                paginate,
            });
            if (gqlRes === null || gqlRes === void 0 ? void 0 : gqlRes[fieldName]) {
                const { nodes = [], edges = [], pageInfo } = gqlRes[fieldName];
                result.push(...nodes);
                result.push(...edges);
                limit = Math.max(0, limit - nodes.length - edges.length);
                if (limit === 0) {
                    isIterating = false;
                }
                else if (paginate && pageInfo) {
                    const { hasNextPage, endCursor } = pageInfo;
                    if (hasNextPage && endCursor) {
                        cursor = endCursor;
                    }
                    else {
                        isIterating = false;
                    }
                }
            }
            else {
                count = Math.floor(count / 2);
                if (count === 0) {
                    logger_1.logger.error({ gqlRes }, 'Error fetching GraphQL nodes');
                    isIterating = false;
                }
            }
            if (!paginate) {
                isIterating = false;
            }
        }
        return result;
    }
}
exports.GithubHttp = GithubHttp;
//# sourceMappingURL=github.js.map