"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getMergeConfidenceLevel = exports.satisfiesConfidenceLevel = exports.isActiveConfidenceLevel = exports.confidenceLevels = void 0;
const logger_1 = require("../../logger");
const memCache = __importStar(require("../cache/memory"));
const packageCache = __importStar(require("../cache/package"));
const hostRules = __importStar(require("../host-rules"));
const http_1 = require("../http");
const http = new http_1.Http('merge-confidence');
const MERGE_CONFIDENCE = ['low', 'neutral', 'high', 'very high'];
exports.confidenceLevels = {
    low: -1,
    neutral: 0,
    high: 1,
    'very high': 2,
};
function isActiveConfidenceLevel(confidence) {
    return confidence !== 'low' && MERGE_CONFIDENCE.includes(confidence);
}
exports.isActiveConfidenceLevel = isActiveConfidenceLevel;
function satisfiesConfidenceLevel(confidence, minimumConfidence) {
    return exports.confidenceLevels[confidence] >= exports.confidenceLevels[minimumConfidence];
}
exports.satisfiesConfidenceLevel = satisfiesConfidenceLevel;
const updateTypeConfidenceMapping = {
    pin: 'high',
    digest: 'neutral',
    bump: 'neutral',
    lockFileMaintenance: 'neutral',
    lockfileUpdate: 'neutral',
    rollback: 'neutral',
    major: null,
    minor: null,
    patch: null,
};
async function getMergeConfidenceLevel(datasource, depName, currentVersion, newVersion, updateType) {
    if (!(currentVersion && newVersion && updateType)) {
        return 'neutral';
    }
    const mappedConfidence = updateTypeConfidenceMapping[updateType];
    if (mappedConfidence) {
        return mappedConfidence;
    }
    const { token } = hostRules.find({
        hostType: 'merge-confidence',
        url: 'https://badges.renovateapi.com',
    });
    if (!token) {
        logger_1.logger.warn('No Merge Confidence API token found');
        return 'neutral';
    }
    // istanbul ignore if
    if (memCache.get('merge-confidence-invalid-token')) {
        return 'neutral';
    }
    const url = `https://badges.renovateapi.com/packages/${datasource}/${depName}/${newVersion}/confidence.api/${currentVersion}`;
    const cachedResult = await packageCache.get('merge-confidence', token + url);
    // istanbul ignore if
    if (cachedResult) {
        return cachedResult;
    }
    let confidence = 'neutral';
    try {
        const res = (await http.getJson(url)).body;
        if (MERGE_CONFIDENCE.includes(res.confidence)) {
            confidence = res.confidence;
        }
    }
    catch (err) {
        logger_1.logger.debug({ err }, 'Error fetching merge confidence');
        if (err.statusCode === 403) {
            memCache.set('merge-confidence-invalid-token', true);
            logger_1.logger.warn('Merge Confidence API token rejected');
        }
    }
    await packageCache.set('merge-confidence', token + url, confidence, 60);
    return confidence;
}
exports.getMergeConfidenceLevel = getMergeConfidenceLevel;
//# sourceMappingURL=index.js.map